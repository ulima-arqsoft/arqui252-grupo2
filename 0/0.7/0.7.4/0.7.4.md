> [0. Acerca del Grupo](../../0.md) ‚Ä∫ [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) ‚Ä∫ [0.7.4. Integrante 4](0.7.4.md)

# 0.7.4. Integrante 4



## PATR√ìN COMPETING CONSUMERS (CONSUMIDORES COMPETIDORES)

### PROBLEMA
El patr√≥n Competing Consumers resuelve el cuello de botella que se genera cuando un √∫nico consumidor debe procesar m√∫ltiples mensajes o tareas de forma secuencial. Los principales problemas que aborda son:

- **Acumulaci√≥n de mensajes**: la cola crece m√°s r√°pido de lo que puede procesarse.
- **Latencia elevada**: tiempos de espera prolongados antes del procesamiento.
- **Subutilizaci√≥n de recursos**: un solo consumidor no aprovecha la capacidad disponible.
- **Falta de escalabilidad**: imposibilidad de ajustar la capacidad seg√∫n la demanda.
- **Punto √∫nico de fallo**: si el consumidor falla, todo el procesamiento se detiene.

Adicionalmente, cuando algunos mensajes requieren m√°s tiempo que otros, se bloquea el procesamiento de tareas m√°s simples. Tambi√©n existe riesgo de p√©rdida de mensajes ante fallos y dificultad para responder a picos repentinos de carga.

### SOLUCI√ìN
El patr√≥n propone m√∫ltiples consumidores concurrentes que compiten por procesar mensajes de la misma cola, distribuyendo autom√°ticamente la carga de trabajo entre todos los disponibles.

Los componentes clave son:

- **Cola de mensajes**: act√∫a como buffer y garantiza que cada mensaje sea procesado por un solo consumidor mediante mecanismos de bloqueo.
- **Grupo de consumidores**: instancias id√©nticas operando independientemente solicitando mensajes, proces√°ndolos y confirmando su ejecuci√≥n.
- **Mecanismo de distribuci√≥n**: puede ser rotativo, basado en carga actual, por prioridad o aleatorio.

Tecnolog√≠as comunes incluyen Azure Service Bus, Amazon SQS, RabbitMQ, Apache Kafka y Google Cloud Pub/Sub.

A diferencia de otros patrones, Competing Consumers garantiza que cada mensaje sea procesado exactamente por un consumidor, mientras que en Publicaci√≥n-Suscripci√≥n un mensaje llega a m√∫ltiples suscriptores. Su objetivo principal es distribuir eficientemente la carga de trabajo mediante escalabilidad horizontal.

### CASOS DE APLICACI√ìN

#### Caso 1: Procesamiento de Pedidos en E-commerce
Plataformas como Amazon o MercadoLibre reciben miles de pedidos por minuto durante eventos especiales. Cuando un usuario completa una compra, m√∫ltiples consumidores compiten por validar inventario, procesar pagos, generar facturas, notificar a log√≠stica y enviar confirmaciones. Durante Black Friday, el sistema escala autom√°ticamente de cincuenta a quinientos consumidores. Si algunos fallan, los dem√°s contin√∫an operando. El rendimiento aumenta de doscientos a m√°s de diez mil pedidos por minuto, con confirmaciones en segundos en lugar de minutos.

#### Caso 2: Procesamiento de Im√°genes en Redes Sociales
Instagram y TikTok procesan millones de fotos y videos diariamente que requieren generar miniaturas, detectar contenido inapropiado, extraer metadatos y optimizar para diferentes dispositivos. Consumidores especializados con GPU ejecutan modelos de inteligencia artificial, mientras otros optimizados para CPU generan miniaturas. El procesamiento paralelo reduce el tiempo de treinta segundos a tres segundos. Instagram procesa aproximadamente noventa y cinco millones de fotos diarias.

#### Caso 3: Sistema de Notificaciones Multicanal
Una startup SaaS env√≠a notificaciones por correo electr√≥nico, SMS, push, webhooks y dentro de la aplicaci√≥n. Grupos especializados de consumidores manejan cada canal: veinte para email usando SendGrid, quince para SMS con Twilio, diez para notificaciones push mediante Firebase. Cada grupo respeta las limitaciones de velocidad de las APIs externas e implementa reintentos inteligentes. Un caso real mostr√≥ crecimiento de mil a quinientas mil notificaciones diarias con sesenta por ciento de reducci√≥n en costos versus servicios completamente administrados.

#### Caso 4: An√°lisis de Registros y Monitoreo
Empresas corporativas generan terabytes de registros diarios de servidores, microservicios, bases de datos e infraestructura de red. Los registros fluyen a Kafka donde consumidores compiten para analizar, normalizar, enriquecer con informaci√≥n adicional, agregar m√©tricas, indexar en Elasticsearch y evaluar reglas de alertas. El procesamiento distribuido garantiza que los registros est√©n disponibles en menos de cinco segundos. Diferentes grupos de consumidores manejan pol√≠ticas de retenci√≥n escribiendo a almacenamiento caliente, tibio o fr√≠o seg√∫n la antig√ºedad.

#### Caso 5: Procesamiento de Transacciones Bancarias
Bancos digitales procesan transferencias, pagos de servicios, dep√≥sitos y validaci√≥n de fraude en tiempo real. La arquitectura usa colas con sesiones para garantizar orden por usuario, cien instancias de consumidores con sesiones persistentes, y monitoreo estricto. Los requisitos incluyen disponibilidad del noventa y nueve punto noventa y nueve por ciento, latencia menor a tres segundos en el percentil noventa y nueve, capacidad de cincuenta mil transacciones por minuto, y cumplimiento de est√°ndares regulatorios como SOC 2 y PCI-DSS.

---

[‚¨ÖÔ∏è Anterior](../0.7.3/0.7.3.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../0.7.5/0.7.5.md)