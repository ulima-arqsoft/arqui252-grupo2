> [0. Acerca del Grupo](../../0.md) â€º [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) â€º [0.7.2. Integrante 2](0.7.2.md)

# 0.7.2. Integrante 2

Tema: Claim-Check
## Claim Check
### Problema

ComÃºnmente, los sistemas de mensajerÃ­a estÃ¡n optimizados para manejar una gran cantidad de mensajes pequeÃ±os y, por lo general, cuentan con una restricciÃ³n en el tamaÃ±o mÃ¡ximo de los mensajes que pueden procesar. Esto se puede observar, por ejemplo, en que la ventana de comunicaciÃ³n entre un cliente y un servidor tiene un tamaÃ±o definido. Teniendo esto en cuenta, si se intenta enviar mensajes muy grandes, estos pueden exceder dichos lÃ­mites o ser lo suficientemente grandes como para ocupar por completo el tamaÃ±o de la ventana de comunicaciÃ³n. Esto puede afectar negativamente el rendimiento del sistema, especialmente cuando el sistema de mensajerÃ­a debe almacenar o transmitir mensajes de gran tamaÃ±o.
### SoluciÃ³n

La soluciÃ³n que propone este patrÃ³n puede resumirse de la siguiente manera: en lugar de enviar todo el payload dentro del mensaje, el patrÃ³n Claim Check almacena la parte pesada del mensaje en un almacenamiento externo (por ejemplo, una base de datos, un servicio de blob storage u otro repositorio similar). A partir de ahÃ­, el mensaje que se envÃ­a solo contiene una referencia o token, conocido como claim check, que indica la ubicaciÃ³n de los datos almacenados. De esta manera, el sistema de mensajerÃ­a Ãºnicamente transmite mensajes livianos, mientras que el componente encargado de procesarlos puede recuperar los datos completos cuando los necesite.
### Casos de aplicaciÃ³n

1. Sistema hospitalario
	- En un sistema de emergencias hospitalarias, durante la etapa de triaje de los pacientes, se deben registrar todos sus datos personales, junto con sus estudios mÃ©dicos, que pueden incluir diversas imÃ¡genes radiogrÃ¡ficas y otros archivos de gran tamaÃ±o. Toda esta informaciÃ³n puede generar un payload muy pesado, por lo que no es recomendable incluirla directamente en los mensajes. En este caso, el servicio de admisiÃ³n debe almacenar estos archivos en un repositorio externo (como un sistema de almacenamiento de objetos o una base de datos), y en el mensaje solo se envÃ­a una referencia a dicha informaciÃ³n mediante un claim check.
2. Ecommerce
	- Al realizar una compra en una tienda en lÃ­nea (por ejemplo, Saga Falabella, Ripley u otras), cada orden puede incluir una lista extensa de productos, comprobantes adjuntos y otros datos adicionales. El servicio encargado de procesar las Ã³rdenes no necesita todos estos datos de manera inmediata, y transmitirlos completamente podrÃ­a sobrecargar la comunicaciÃ³n. Por ello, el servicio de checkout puede almacenar el detalle completo de la orden en una base de datos y enviar en el mensaje solo una referencia (claim check). De esta forma, los servicios de logÃ­stica o facturaciÃ³n pueden recuperar los datos completos de la orden Ãºnicamente cuando los necesiten.
3. Redes Sociales
	- En el caso de las redes sociales (como Facebook o Instagram), cuando un usuario sube una foto, historia o reel, el archivo multimedia puede tener un tamaÃ±o considerable, mientras que el resto del contenido del mensaje (como el texto, hashtags o ubicaciÃ³n) es mucho mÃ¡s liviano. Enviar todo el payload en el mensaje no serÃ­a eficiente ni escalable, por lo que el patrÃ³n Claim Check resulta ideal. En este escenario, el usuario carga el archivo multimedia directamente a un servicio de almacenamiento (por ejemplo, un bucket en Amazon S3 o el sistema interno de la red social), y el sistema genera un identificador Ãºnico, claim check, que actÃºa como referencia al archivo. Luego, el cliente envÃ­a al backend de publicaciones un mensaje que contiene solo los datos livianos y el claim check, permitiendo que el backend recupere el contenido multimedia completo Ãºnicamente cuando lo necesite.

### AplicaciÃ³n en su proyecto grupal

Se propone implementar el patrÃ³n Claim Check en el mÃ³dulo de administraciÃ³n general, especÃ­ficamente en la funcionalidad de gestiÃ³n de cuentas de usuario, donde el administrador deberÃ­a poder visualizar un listado extenso de todos los usuarios registrados en la plataforma junto con su informaciÃ³n asociada. En el escenario actual, el servicio devolverÃ­a todos los datos vinculados a cada cuenta, incluyendo archivos como fotos de perfil o historiales de actividad, lo que podrÃ­a afectar el rendimiento y aumentar los tiempos de respuesta ante solicitudes concurrentes.

Al aplicar el patrÃ³n Claim Check, el sistema almacenarÃ­a los datos pesados en un servicio externo de almacenamiento y enviarÃ­a Ãºnicamente referencias a travÃ©s de los mensajes. De este modo, la carga principal de la respuesta contendrÃ­a solo la informaciÃ³n esencial, mientras que los datos completos se recuperarÃ­an Ãºnicamente cuando el administrador los solicitara (por ejemplo, al consultar los detalles de un usuario especÃ­fico). Con esta implementaciÃ³n se esperarÃ­a reducir el consumo de ancho de banda y memoria del backend, manteniendo los tiempos de respuesta por debajo de los tres segundos.

---

### Desarrollo de CÃ³digo

Para la demostraciÃ³n, se ha seleccionado uno de los casos propuestos en la secciÃ³n deÂ casos de aplicaciÃ³n, especÃ­ficamente el uso delÂ patrÃ³n Claim CheckÂ enÂ sistemas hospitalarios, donde se trabaja con una gran cantidad de archivos pertenecientes a un solo paciente. En este tipo de entornos, losÂ payloadsÂ con archivos pesados son comunes en las operaciones diarias, por lo que el uso del patrÃ³n Claim Check resulta ideal para optimizar la transferencia y el manejo de informaciÃ³n.

#### **Escenario**

En un sistema deÂ emergencias hospitalarias, durante la etapa deÂ triaje de pacientes, se deben registrar todos sus datos personales junto con sus estudios mÃ©dicos, que pueden incluir diversas imÃ¡genes radiogrÃ¡ficas, reportes clÃ­nicos y otros archivos de gran tamaÃ±o.  
Toda esta informaciÃ³n puede generarÂ payloadsÂ pesados, por lo queÂ no es recomendable incluir los archivos directamente en los mensajes. En su lugar, el servicio de admisiÃ³n almacena los archivos en unÂ repositorio externo(por ejemplo, un sistema de almacenamiento de objetos o una base de datos), y en el mensaje solo se envÃ­a unaÂ referencia a dicha informaciÃ³nÂ mediante unÂ claim check.

#### **ImplementaciÃ³n**

Para la implementaciÃ³n del patrÃ³nÂ Claim Check, se desarrollÃ³ una pequeÃ±a demo utilizando el siguienteÂ stack tecnolÃ³gico:

FrontEnd:
- Node.js
- React
- Vite
BackEnd:
- Express.js
- Sequelize ORM
Base de Datos:
- PostgreSQL

El propÃ³sito de la demo esÂ simular una interfaz de gestiÃ³n de pacientes en un Ã¡rea de emergencias, donde se puedan visualizar los pacientes registrados, sus datos personales y los archivos asociados (radiografÃ­as, reportes, exÃ¡menes, etc.).  
AdemÃ¡s, permiteÂ registrar nuevos pacientes y adjuntar mÃºltiples archivosÂ durante el registro, demostrando asÃ­ cÃ³mo el patrÃ³n Claim Check reduce el tamaÃ±o delÂ payloadÂ al almacenar los archivos externamente y mantener solo la referencia en la base de datos.
#### **Pasos de ImplementaciÃ³n**

1. DiseÃ±o de la base de datos y modelos:  
    Se crearon los modelos principales:
    
    - PatientÂ (representa los datos personales del paciente).
        
    - FileÂ (representa los archivos asociados a cada paciente).  
        Se definiÃ³ una relaciÃ³nÂ uno a muchos, donde un paciente puede tener mÃºltiples archivos relacionados.  
        
	![Model_1](File_Model.png)
	![Model_2](Patient_Model.png)
        
2. DefiniciÃ³n de las API principales: 
    Se implementaron las rutas principales:
    
    - Una API para procesar la informaciÃ³nÂ ligera del pacienteÂ (nombre, edad, etc.).
    - Una API para procesar losÂ archivosÂ asociados.  
        AdemÃ¡s, se creÃ³ una versiÃ³n adicional que permiteÂ agregar archivos de manera individual.
	    
	![Api_1](Api_Patients.png)
	![Api_2](Api_Files.png)

3. GeneraciÃ³n del Claim Check:  
    En las API encargadas de recibir los archivos, se utilizÃ³ la librerÃ­aÂ UUIDÂ para generarÂ identificadores ÃºnicosÂ que sirven comoÂ claim check.  
    Cada archivo se guarda en un almacenamiento local (que simula unÂ almacenamiento en la nube, como Amazon S3), y en la base de datos solo se guarda laÂ referencia al archivoÂ junto con su identificador y metadatos (nombre, ruta, fecha de carga). 

    ![Api_3](Api_File.png)
    
4. CreaciÃ³n de las API de recuperaciÃ³n de datos:  
    Se desarrollÃ³ una API paraÂ recuperar los archivos almacenados.  
    El servicio busca el archivo en el almacenamiento externo y, en caso de no encontrarlo, devuelve un mensaje de error.  
    Si se tratara de un almacenamiento en la nube, la verificaciÃ³n se harÃ­a consultando unaÂ URL externa.  
    ![Api_4](Api_ClaimCheck.png)
    
5. Pruebas y validaciÃ³n con Postman:  
    Se probaron las API principales con Postman para verificar que:
    - En la base de datosÂ solo se almacena la referenciaÂ a los archivos.
    - En las solicitudes del cliente,Â no se envÃ­a el archivo completo, sino la referencia generada (Claim Check).
    
	![Postman_1](Postman_1.png)
	![Postman_2](Postman_2.png)
	![Postman_3](Postman_3.png)
        
6. ImplementaciÃ³n del Frontend para la Demo:  
    Se desarrollÃ³ una interfaz que incluye:
    - Una pantalla principal que muestra los pacientes registrados y sus datos.
    - UnÂ modal para visualizar los archivosÂ asociados a cada paciente y permitir subir nuevos archivos.
    - UnÂ modal para registrar nuevos pacientesÂ y adjuntar mÃºltiples archivos en el mismo proceso.
---
#### **Demo**

En la demo final se puede observar cÃ³mo el sistema gestiona de forma eficiente los archivos asociados a los pacientes, reduciendo el tamaÃ±o delÂ payloadÂ gracias al uso del patrÃ³nÂ Claim Check. La arquitectura implementada permite simular el flujo de un sistema hospitalario de emergencia, demostrando cÃ³mo separar los datos pesados del cuerpo principal del mensaje mejora la eficiencia, escalabilidad y rendimiento del sistema.

![Demo_1](Demo_1.png)
![Demo_2](Demo_2.png)
![Demo_3](Demo_3.png)
![Demo_4](Demo_4.png)

Codigo: [Repo_Individual](https://github.com/ulima-arqsoft/arqui252-rodriguez-ybarra.git)



[â¬…ï¸ Anterior](../0.7.1/0.7.1.md) | [ğŸ  Home](../../../README.md) | [Siguiente â¡ï¸](../0.7.3/0.7.3.md)