> [8. Aplicaci√≥n de Patrones Arquitecturales](../8.md) ‚Ä∫ [8.2. M√≥dulo 2 / Integrante 2](8.2.md)

# 8.2. M√≥dulo 2 / Integrante 2

## Patr√≥n de M√≥dulo: Modelo‚ÄìVista‚ÄìControlador (MVC)

**T√≠tulo**

Elecci√≥n del patr√≥n Modelo‚ÄìVista‚ÄìControlador (MVC) para estructuraci√≥n del m√≥dulo de Administraci√≥n General

---

**Contexto**

El microservicio de Administraci√≥n General debe exponer operaciones de gesti√≥n (profesores, cursos, asignaciones, m√©tricas y dashboard) y coordinar datos provenientes de varios m√≥dulos externos. Para ello se requiere un patr√≥n claro de separaci√≥n de responsabilidades que permita mantener orden y escalabilidad entre la l√≥gica del backend, los modelos de datos y las vistas consumidas por el frontend.

---

**Alternativas**

**1. Estructura monol√≠tica sin separaci√≥n expl√≠cita**

- Simplicidad inicial.
    
- Dificulta el mantenimiento.
    
- Alto acoplamiento entre l√≥gica, datos y vistas.
    

**2. Domain-Driven Design (DDD)**

- Alta claridad conceptual y modular.
    
- Costoso para el tama√±o del proyecto.
    
- Introduce complejidad innecesaria para CRUDs administrativos.
    

**3. Clean Architecture**

- Gran independencia entre capas.
    
- Requiere m√°s tiempo y m√°s capas (use cases, adapters).
    
- No aporta beneficios suficientes para operaciones r√°pidas tipo CRUD.
    

**4. Modelo‚ÄìVista‚ÄìControlador (MVC) (seleccionada)**

- Separaci√≥n clara: modelos (DB), controladores (l√≥gica), vistas (frontend).
    
- Encaja naturalmente con microservicios REST.
    
- Facilita pruebas, mantenimiento y escalabilidad.
    
- Compatible con React (vista) y Express (controladores).
    

---

**Criterios de Elecci√≥n**

- Necesidad de orden y claridad sin sobre-ingenier√≠a.
    
- Compatibilidad con la arquitectura REST existente.
    
- Rapidez de adopci√≥n y soporte por parte del equipo.
    
- Soporte natural a los requisitos funcionales (gesti√≥n CRUD, dashboard).
    

---

**Decisi√≥n**

Se adopta el patr√≥n¬†Modelo‚ÄìVista‚ÄìControlador¬†para el microservicio de Administraci√≥n General.

---

**Sustento**

MVC permite separar adecuadamente los modelos de base de datos, la l√≥gica de negocio en los controladores y las vistas entregadas al frontend. Esto reduce acoplamiento y facilita el mantenimiento del m√≥dulo administrativo, donde se gestionan profesores, cursos, asignaciones y dashboard. La estructura permiti√≥ integrar las tablas propias del microservicio y las tablas cach√© sincronizadas sin romper la modularidad.

---

**Aplicaci√≥n en el Proyecto**

- **Modelo:** Sequelize define los modelos (profesor, curso, asignaci√≥n, m√©tricas, tablas cache).
    
- **Controlador:**¬†Express implementa las rutas y l√≥gica de negocio.
    
- **Vista:**¬†React consume los endpoints y renderiza UI administrativa.
    
- El patr√≥n permiti√≥ reemplazar tablas externas por tablas cach√© sin alterar la vista ni los controladores.
    

---


## ADR 02 ‚Äî Patr√≥n de Componente y Conector: Publish‚ÄìSubscribe con RabbitMQ

**T√≠tulo**

Uso del patr√≥n Publish‚ÄìSubscribe mediante RabbitMQ para la sincronizaci√≥n entre microservicios

---

**Contexto**

El microservicio de Administraci√≥n General requiere informaci√≥n de otros microservicios (Usuarios, Rese√±as, Cursos, etc.). Como no es due√±o de esas tablas, necesita recibir cambios en tiempo real sin depender de consultas costosas ni acoplamiento directo mediante llamadas REST repetitivas.

Se requiere un mecanismo que permita:

- Recibir actualizaciones en forma as√≠ncrona,
    
- Mantener tablas cach√© actualizadas,
    
- Evitar acoplamiento fuerte entre servicios,
    
- Resistir picos de mensajes (ESC-04).
    

---

**Alternativas**

**1. Llamadas REST peri√≥dicas (polling)**

- F√°cil de implementar.
    
- Alto costo en la base de datos.
    
- Latencia elevada y riesgo de inconsistencia.
    

**2. REST s√≠ncrono entre microservicios (acoplamiento directo)**

- Latencia baja cuando funciona.
    
- Dependencia fuerte: si un microservicio cae, el resto falla.
    
- Mala pr√°ctica en arquitecturas distribuidas.
    

**3. Event Streaming con Kafka**

- Excelente rendimiento y alta escalabilidad.
    
- Demasiado complejo y costoso para el tama√±o del proyecto.
    
- Requiere infraestructura especializada.
    

**4. Publish‚ÄìSubscribe con RabbitMQ (seleccionada)**

- Desacoplado.
    
- As√≠ncrono.
    
- Ideal para microservicios medianos.
    
- Permite eventos de create/update/delete.
    
- Facilita aplicar t√°cticas de rendimiento (rate-limiting y cola acotada).
    

---

**Criterios de Elecci√≥n**

- Desacoplamiento entre microservicios.
    
- Facilidad de consumo en Node.js.
    
- Control del flujo de mensajes durante picos.
    
- Integraci√≥n natural con tablas cach√©.
    
- Soporte a escenarios ESC-04.
    

---

**Decisi√≥n**

Se adopta el patr√≥n Publish‚ÄìSubscribe implementado con RabbitMQ para recibir todos los eventos que actualizan las tablas cach√© del m√≥dulo de Administraci√≥n General.

---

**Sustento**

RabbitMQ permite que cada microservicio publique eventos sin conocer a los consumidores. El microservicio de Administraci√≥n General recibe estos eventos, actualiza sus tablas cach√© y mantiene sus vistas sin necesidad de llamar constantemente a otros servicios. Adem√°s, la soluci√≥n permiti√≥ aplicar t√°cticas de rendimiento cr√≠ticas:¬†rate-limiting¬†y¬†bounded queue, garantizando que la cola nunca crezca m√°s de 200 mensajes y la latencia no supere los 150 ms incluso bajo carga.

---

**Aplicaci√≥n en el Proyecto**

- Un¬†consumer¬†escucha eventos de Usuarios, Cursos y Rese√±as.
    
- Ante un evento, actualiza la tabla cach√© correspondiente.
    
- Redis se invalida o refresca seg√∫n el tipo de evento.
    
- La vista de administraci√≥n obtiene datos limpios y consistentes sin golpear la base externa.
    

---

---

## ADR 03 ‚Äî Patr√≥n de Asignaci√≥n: Arquitectura Multicapa Parcial (Multi-Tier)

**T√≠tulo**

Asignaci√≥n de componentes mediante un enfoque Multi-Tier parcial: BD en la nube, frontend y backend locales

---

**Contexto**

Durante el desarrollo del microservicio de Administraci√≥n General se necesitaba un entorno que permitiera pruebas r√°pidas y despliegues parciales sin obligar al equipo a levantar toda la nube. Sin embargo, la base de datos s√≠ deb√≠a estar centralizada para garantizar integridad y consistencia.

---

**Alternativas**

**1. Todo local (BD + backend + frontend locales)**

- F√°cil de levantar.
    
- No reproduce condiciones reales de despliegue.
    
- Riesgo de inconsistencias entre m√°quinas del equipo.
    

**2. Todo en la nube**

- Reproduce perfectamente el entorno final.
    
- Alto costo.
    
- Mayor fricci√≥n para pruebas r√°pidas.
    

**3. Contenerizaci√≥n completa con Docker Compose**

- Aislado, replicable.
    
- Requiere m√°s tiempo y configuraci√≥n.
    
- No era obligatorio en el curso.
    

**4. Multi-Tier parcial (seleccionada)**

- BD centralizada en la nube.
    
- Backend y frontend locales.
    
- Balance entre realismo y velocidad de desarrollo.
    
- Compatible con microservicios independientes.
    

---

**Criterios de Elecci√≥n**

- Rapidez de desarrollo.
    
- Reproducci√≥n parcial del entorno real.
    
- Acceso consistente a la base de datos remota.
    
- Evitar costos altos en infraestructura.
    
- Permitir trabajo independiente por microservicio.
    

---

**Decisi√≥n**

Se adopta un modelo Multi-Tier parcial donde:

- **Tier 1 (Datos):**¬†Base de datos PostgreSQL en la nube.
    
- **Tier 2 (L√≥gica):**¬†Backend local del microservicio.
    
- **Tier 3 (Presentaci√≥n):**¬†Frontend local.
    

---

**Sustento**

El enfoque permite una integraci√≥n realista con la base de datos mientras mantiene la flexibilidad del desarrollo local. Como el microservicio depende de tablas propias y tambi√©n de tablas cach√©, esta configuraci√≥n facilit√≥ sincronizaci√≥n, pruebas y despliegue sin necesidad de un entorno cloud completo. Adem√°s, permiti√≥ mantener consistencia de datos cuando m√∫ltiples desarrolladores interactuaban con el servicio.

---

**Aplicaci√≥n en el Proyecto**

- PostgreSQL est√° alojado en un servicio cloud accesible por todos.
    
- Cada miembro corre su backend localmente.
    
- El frontend React se conecta al backend mediante CORS configurado.
    
- RabbitMQ opera como componente compartido para sincronizaci√≥n.

---

[‚¨ÖÔ∏è Anterior](../8.1/8.1.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../8.3/8.3.md)